const ease = (k) => {
    return 0.5 * (1 - Math.cos(Math.PI * k));
};
const DURATION = 500;
export const isScrollBehaviorSupported = () => "scrollBehavior" in document.documentElement.style;
export const original = {
    _elementScroll: undefined,
    get elementScroll() {
        return (this._elementScroll || (this._elementScroll = HTMLElement.prototype.scroll ||
            HTMLElement.prototype.scrollTo ||
            function (x, y) {
                this.scrollLeft = x;
                this.scrollTop = y;
            }));
    },
    _elementScrollIntoView: undefined,
    get elementScrollIntoView() {
        return (this._elementScrollIntoView || (this._elementScrollIntoView = HTMLElement.prototype.scrollIntoView));
    },
    _windowScroll: undefined,
    get windowScroll() {
        return (this._windowScroll || (this._windowScroll = window.scroll || window.scrollTo));
    },
};
export const modifyPrototypes = (modification) => {
    const prototypes = [HTMLElement.prototype, SVGElement.prototype, Element.prototype];
    prototypes.forEach((prototype) => modification(prototype));
};
export const now = () => { var _a, _b, _c; return (_c = (_b = (_a = window.performance) === null || _a === void 0 ? void 0 : _a.now) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : Date.now(); };
export const step = (context) => {
    const currentTime = now();
    const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);
    if (elapsed > 1) {
        context.method(context.targetX, context.targetY);
        context.callback();
        return;
    }
    const value = (context.timingFunc || ease)(elapsed);
    const currentX = context.startX + (context.targetX - context.startX) * value;
    const currentY = context.startY + (context.targetY - context.startY) * value;
    context.method(currentX, currentY);
    context.rafId = requestAnimationFrame(() => {
        step(context);
    });
};
// https://drafts.csswg.org/cssom-view/#normalize-non-finite-values
export const nonFinite = (value) => {
    if (!isFinite(value)) {
        return 0;
    }
    return Number(value);
};
export const isObject = (value) => {
    const type = typeof value;
    return value !== null && (type === "object" || type === "function");
};
//# sourceMappingURL=common.js.map