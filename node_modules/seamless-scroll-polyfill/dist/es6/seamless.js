(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.seamless = {}));
}(this, (function (exports) { 'use strict';

    const ease = (k) => {
        return 0.5 * (1 - Math.cos(Math.PI * k));
    };
    const DURATION = 500;
    const isScrollBehaviorSupported = () => "scrollBehavior" in document.documentElement.style;
    const original = {
        _elementScroll: undefined,
        get elementScroll() {
            return (this._elementScroll || (this._elementScroll = HTMLElement.prototype.scroll ||
                HTMLElement.prototype.scrollTo ||
                function (x, y) {
                    this.scrollLeft = x;
                    this.scrollTop = y;
                }));
        },
        _elementScrollIntoView: undefined,
        get elementScrollIntoView() {
            return (this._elementScrollIntoView || (this._elementScrollIntoView = HTMLElement.prototype.scrollIntoView));
        },
        _windowScroll: undefined,
        get windowScroll() {
            return (this._windowScroll || (this._windowScroll = window.scroll || window.scrollTo));
        },
    };
    const modifyPrototypes = (modification) => {
        const prototypes = [HTMLElement.prototype, SVGElement.prototype, Element.prototype];
        prototypes.forEach((prototype) => modification(prototype));
    };
    const now = () => { var _a, _b, _c; return (_c = (_b = (_a = window.performance) === null || _a === void 0 ? void 0 : _a.now) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : Date.now(); };
    const step = (context) => {
        const currentTime = now();
        const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);
        if (elapsed > 1) {
            context.method(context.targetX, context.targetY);
            context.callback();
            return;
        }
        const value = (context.timingFunc || ease)(elapsed);
        const currentX = context.startX + (context.targetX - context.startX) * value;
        const currentY = context.startY + (context.targetY - context.startY) * value;
        context.method(currentX, currentY);
        context.rafId = requestAnimationFrame(() => {
            step(context);
        });
    };
    // https://drafts.csswg.org/cssom-view/#normalize-non-finite-values
    const nonFinite = (value) => {
        if (!isFinite(value)) {
            return 0;
        }
        return Number(value);
    };
    const isObject = (value) => {
        const type = typeof value;
        return value !== null && (type === "object" || type === "function");
    };

    const elementScroll = (element, options) => {
        var _a, _b;
        const originalBoundFunc = original.elementScroll.bind(element);
        if (options.left === undefined && options.top === undefined) {
            return;
        }
        const startX = element.scrollLeft;
        const startY = element.scrollTop;
        const targetX = nonFinite((_a = options.left) !== null && _a !== void 0 ? _a : startX);
        const targetY = nonFinite((_b = options.top) !== null && _b !== void 0 ? _b : startY);
        if (options.behavior !== "smooth") {
            return originalBoundFunc(targetX, targetY);
        }
        const removeEventListener = () => {
            window.removeEventListener("wheel", cancelScroll);
            window.removeEventListener("touchmove", cancelScroll);
        };
        const context = {
            timeStamp: now(),
            duration: options.duration,
            startX,
            startY,
            targetX,
            targetY,
            rafId: 0,
            method: originalBoundFunc,
            timingFunc: options.timingFunc,
            callback: removeEventListener,
        };
        const cancelScroll = () => {
            cancelAnimationFrame(context.rafId);
            removeEventListener();
        };
        window.addEventListener("wheel", cancelScroll, {
            passive: true,
            once: true,
        });
        window.addEventListener("touchmove", cancelScroll, {
            passive: true,
            once: true,
        });
        step(context);
    };
    const elementScrollPolyfill = (animationOptions) => {
        if (isScrollBehaviorSupported()) {
            return;
        }
        const originalFunc = original.elementScroll;
        modifyPrototypes((prototype) => (prototype.scroll = function scroll() {
            if (arguments.length === 1) {
                const scrollOptions = arguments[0];
                if (!isObject(scrollOptions)) {
                    throw new TypeError("Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.");
                }
                return elementScroll(this, Object.assign(Object.assign({}, scrollOptions), animationOptions));
            }
            return originalFunc.apply(this, arguments);
        }));
    };

    const elementScrollBy = (element, options) => {
        const left = nonFinite(options.left || 0) + element.scrollLeft;
        const top = nonFinite(options.top || 0) + element.scrollTop;
        return elementScroll(element, Object.assign(Object.assign({}, options), { left, top }));
    };
    const elementScrollByPolyfill = (animationOptions) => {
        if (isScrollBehaviorSupported()) {
            return;
        }
        modifyPrototypes((prototype) => (prototype.scrollBy = function scrollBy() {
            if (arguments.length === 1) {
                const scrollByOptions = arguments[0];
                if (!isObject(scrollByOptions)) {
                    throw new TypeError("Failed to execute 'scrollBy' on 'Element': parameter 1 ('options') is not an object.");
                }
                return elementScrollBy(this, Object.assign(Object.assign({}, scrollByOptions), animationOptions));
            }
            const left = Number(arguments[0]);
            const top = Number(arguments[1]);
            return elementScrollBy(this, { left, top });
        }));
    };

    // https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/dom/element.cc?l=647-681&rcl=02a6466f4efa021e4e198f373eccda3cfc56142b
    const toPhysicalAlignment = (options, axis, isHorizontalWritingMode, isFlippedBlocksMode) => {
        const alignment = (axis === 0 /* HorizontalScroll */ && isHorizontalWritingMode) ||
            (axis === 1 /* VerticalScroll */ && !isHorizontalWritingMode)
            ? options.inline
            : options.block;
        if (alignment === "center") {
            return 1 /* AlignCenterAlways */;
        }
        if (alignment === "nearest") {
            return 0 /* AlignToEdgeIfNeeded */;
        }
        if (alignment === "start") {
            return axis === 0 /* HorizontalScroll */
                ? isFlippedBlocksMode
                    ? 5 /* AlignRightAlways */
                    : 4 /* AlignLeftAlways */
                : 2 /* AlignTopAlways */;
        }
        if (alignment === "end") {
            return axis === 0 /* HorizontalScroll */
                ? isFlippedBlocksMode
                    ? 4 /* AlignLeftAlways */
                    : 5 /* AlignRightAlways */
                : 3 /* AlignBottomAlways */;
        }
        // Default values
        if (isHorizontalWritingMode) {
            return axis === 0 /* HorizontalScroll */
                ? 0 /* AlignToEdgeIfNeeded */
                : 2 /* AlignTopAlways */;
        }
        return axis === 0 /* HorizontalScroll */
            ? 4 /* AlignLeftAlways */
            : 0 /* AlignToEdgeIfNeeded */;
    };
    // code from stipsan/compute-scroll-into-view
    // https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts
    /**
     * Find out which edge to align against when logical scroll position is "nearest"
     * Interesting fact: "nearest" works similarily to "if-needed", if the element is fully visible it will not scroll it
     *
     * Legends:
     * ┌────────┐ ┏ ━ ━ ━ ┓
     * │ target │   frame
     * └────────┘ ┗ ━ ━ ━ ┛
     */
    const alignNearest = (scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) => {
        /**
         * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B
         *
         *          ┌──┐
         *        ┏━│━━│━┓
         *          │  │
         *        ┃ │  │ ┃        do nothing
         *          │  │
         *        ┗━│━━│━┛
         *          └──┘
         *
         *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D
         *
         *    ┏ ━ ━ ━ ━ ┓
         *   ┌───────────┐
         *   │┃         ┃│        do nothing
         *   └───────────┘
         *    ┗ ━ ━ ━ ━ ┛
         */
        if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||
            (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {
            return 0;
        }
        /**
         * If element edge A is outside scrolling box edge A and element height is less than scrolling box height
         *
         *          ┌──┐
         *        ┏━│━━│━┓         ┏━┌━━┐━┓
         *          └──┘             │  │
         *  from  ┃      ┃     to  ┃ └──┘ ┃
         *
         *        ┗━ ━━ ━┛         ┗━ ━━ ━┛
         *
         * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height
         *
         *        ┏━ ━━ ━┓         ┏━┌━━┐━┓
         *                           │  │
         *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃
         *          │  │             │  │
         *        ┗━│━━│━┛         ┗━│━━│━┛
         *          │  │             └──┘
         *          │  │
         *          └──┘
         *
         * If element edge C is outside scrolling box edge C and element width is less than scrolling box width
         *
         *       from                 to
         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
         *  ┌───┐                 ┌───┐
         *  │ ┃ │       ┃         ┃   │     ┃
         *  └───┘                 └───┘
         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
         *
         * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width
         *
         *       from                 to
         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
         *        ┌───────────┐   ┌───────────┐
         *    ┃   │     ┃     │   ┃         ┃ │
         *        └───────────┘   └───────────┘
         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
         */
        if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||
            (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {
            return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
        }
        /**
         * If element edge B is outside scrolling box edge B and element height is less than scrolling box height
         *
         *        ┏━ ━━ ━┓         ┏━ ━━ ━┓
         *
         *  from  ┃      ┃     to  ┃ ┌──┐ ┃
         *          ┌──┐             │  │
         *        ┗━│━━│━┛         ┗━└━━┘━┛
         *          └──┘
         *
         * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height
         *
         *          ┌──┐
         *          │  │
         *          │  │             ┌──┐
         *        ┏━│━━│━┓         ┏━│━━│━┓
         *          │  │             │  │
         *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃
         *                           │  │
         *        ┗━ ━━ ━┛         ┗━└━━┘━┛
         *
         * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width
         *
         *           from                 to
         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
         *  ┌───────────┐           ┌───────────┐
         *  │     ┃     │   ┃       │ ┃         ┃
         *  └───────────┘           └───────────┘
         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
         *
         * If element edge D is outside scrolling box edge D and element width is less than scrolling box width
         *
         *           from                 to
         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓
         *                ┌───┐             ┌───┐
         *        ┃       │ ┃ │       ┃     │   ┃
         *                └───┘             └───┘
         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛
         *
         */
        if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||
            (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {
            return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
        }
        return 0;
    };
    const canOverflow = (overflow) => {
        return overflow !== "visible" && overflow !== "clip";
    };
    const isScrollable = (element) => {
        if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {
            const style = getComputedStyle(element);
            return canOverflow(style.overflowY) || canOverflow(style.overflowX);
        }
        return false;
    };
    const parentElement = (element) => {
        const parentNode = element.parentNode;
        return (parentNode &&
            (parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE
                ? parentNode.host
                : parentNode));
    };
    const elementScrollIntoView = (element, options) => {
        if (!element.ownerDocument.documentElement.contains(element)) {
            return;
        }
        // On Chrome and Firefox, document.scrollingElement will return the <html> element.
        // Safari, document.scrollingElement will return the <body> element.
        // On Edge, document.scrollingElement will return the <body> element.
        // IE11 does not support document.scrollingElement, but you can assume its <html>.
        // Used to handle the top most element that can be scrolled
        const scrollingElement = document.scrollingElement || document.documentElement;
        // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box
        const frames = [];
        for (let cursor = parentElement(element); cursor !== null; cursor = parentElement(cursor)) {
            // Stop when we reach the viewport
            if (cursor === scrollingElement) {
                frames.push(cursor);
                break;
            }
            // Skip document.body if it's not the scrollingElement and documentElement isn't independently scrollable
            if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {
                continue;
            }
            // Now we check if the element is scrollable,
            // this code only runs if the loop haven't already hit the viewport or a custom boundary
            if (isScrollable(cursor)) {
                frames.push(cursor);
            }
        }
        // Support pinch-zooming properly, making sure elements scroll into the visual viewport
        // Browsers that don't support visualViewport
        // will report the layout viewport dimensions on document.documentElement.clientWidth/Height
        // and viewport dimensions on window.innerWidth/Height
        // https://www.quirksmode.org/mobile/viewports2.html
        // https://bokand.github.io/viewport/index.html
        const viewportWidth = window.visualViewport ? window.visualViewport.width : innerWidth;
        const viewportHeight = window.visualViewport ? window.visualViewport.height : innerHeight;
        // Newer browsers supports scroll[X|Y], page[X|Y]Offset is
        const viewportX = window.scrollX || window.pageXOffset;
        const viewportY = window.scrollY || window.pageYOffset;
        const { height: targetHeight, width: targetWidth, top: targetTop, right: targetRight, bottom: targetBottom, left: targetLeft, } = element.getBoundingClientRect();
        const computedStyle = getComputedStyle(element);
        const writingMode = computedStyle.writingMode ||
            computedStyle.getPropertyValue("-webkit-writing-mode") ||
            computedStyle.getPropertyValue("-ms-writing-mode") ||
            "horizontal-tb";
        const isHorizontalWritingMode = ["horizontal-tb", "lr", "lr-tb", "rl"].some((mode) => mode === writingMode);
        const isFlippedBlocksWritingMode = ["vertical-rl", "tb-rl"].some((mode) => mode === writingMode);
        const alignX = toPhysicalAlignment(options, 0 /* HorizontalScroll */, isHorizontalWritingMode, isFlippedBlocksWritingMode);
        const alignY = toPhysicalAlignment(options, 1 /* VerticalScroll */, isHorizontalWritingMode, isFlippedBlocksWritingMode);
        let targetBlock = (() => {
            switch (alignY) {
                case 2 /* AlignTopAlways */:
                case 0 /* AlignToEdgeIfNeeded */:
                    return targetTop;
                case 3 /* AlignBottomAlways */:
                    return targetBottom;
                // case ScrollAlignment.AlignCenterAlways:
                default:
                    return targetTop + targetHeight / 2;
            }
        })();
        let targetInline = (() => {
            switch (alignX) {
                case 1 /* AlignCenterAlways */:
                    return targetLeft + targetWidth / 2;
                case 5 /* AlignRightAlways */:
                    return targetRight;
                // case ScrollAlignment.AlignLeftAlways:
                // case ScrollAlignment.AlignToEdgeIfNeeded:
                default:
                    return targetLeft;
            }
        })();
        const actions = [];
        for (const frame of frames) {
            const { height, width, top, right, bottom, left } = frame.getBoundingClientRect();
            const frameStyle = getComputedStyle(frame);
            const borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
            const borderTop = parseInt(frameStyle.borderTopWidth, 10);
            const borderRight = parseInt(frameStyle.borderRightWidth, 10);
            const borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
            let blockScroll = 0;
            let inlineScroll = 0;
            // The property existance checks for offfset[Width|Height] is because only HTMLElement objects have them,
            // but any Element might pass by here
            // @TODO find out if the "as HTMLElement" overrides can be dropped
            const scrollbarWidth = "offsetWidth" in frame
                ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight
                : 0;
            const scrollbarHeight = "offsetHeight" in frame
                ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom
                : 0;
            if (scrollingElement === frame) {
                // Handle viewport logic (document.documentElement or document.body)
                switch (alignY) {
                    case 2 /* AlignTopAlways */: {
                        blockScroll = targetBlock;
                        break;
                    }
                    case 3 /* AlignBottomAlways */: {
                        blockScroll = targetBlock - viewportHeight;
                        break;
                    }
                    case 1 /* AlignCenterAlways */: {
                        blockScroll = targetBlock - viewportHeight / 2;
                        break;
                    }
                    case 0 /* AlignToEdgeIfNeeded */: {
                        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
                        break;
                    }
                }
                switch (alignX) {
                    case 4 /* AlignLeftAlways */: {
                        inlineScroll = targetInline;
                        break;
                    }
                    case 5 /* AlignRightAlways */: {
                        inlineScroll = targetInline - viewportWidth;
                        break;
                    }
                    case 1 /* AlignCenterAlways */: {
                        inlineScroll = targetInline - viewportWidth / 2;
                        break;
                    }
                    case 0 /* AlignToEdgeIfNeeded */: {
                        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
                        break;
                    }
                }
                // Apply scroll position offsets and ensure they are within bounds
                blockScroll = Math.max(0, blockScroll + viewportY);
                inlineScroll = Math.max(0, inlineScroll + viewportX);
            }
            else {
                // Handle each scrolling frame that might exist between the target and the viewport
                switch (alignY) {
                    case 2 /* AlignTopAlways */: {
                        blockScroll = targetBlock - top - borderTop;
                        break;
                    }
                    case 3 /* AlignBottomAlways */: {
                        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
                        break;
                    }
                    case 1 /* AlignCenterAlways */: {
                        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;
                        break;
                    }
                    case 0 /* AlignToEdgeIfNeeded */: {
                        blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
                        break;
                    }
                }
                switch (alignX) {
                    case 4 /* AlignLeftAlways */: {
                        inlineScroll = targetInline - left - borderLeft;
                        break;
                    }
                    case 5 /* AlignRightAlways */: {
                        inlineScroll = targetInline - right + borderRight + scrollbarWidth;
                        break;
                    }
                    case 1 /* AlignCenterAlways */: {
                        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;
                        break;
                    }
                    case 0 /* AlignToEdgeIfNeeded */: {
                        inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
                        break;
                    }
                }
                const { scrollLeft, scrollTop } = frame;
                // Ensure scroll coordinates are not out of bounds while applying scroll offsets
                blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - height + scrollbarHeight));
                inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - width + scrollbarWidth));
                // Cache the offset so that parent frames can scroll this into view correctly
                targetBlock += scrollTop - blockScroll;
                targetInline += scrollLeft - inlineScroll;
            }
            actions.push(() => elementScroll(frame, Object.assign(Object.assign({}, options), { top: blockScroll, left: inlineScroll })));
        }
        actions.forEach((run) => run());
    };
    const elementScrollIntoViewPolyfill = (animationOptions) => {
        if (isScrollBehaviorSupported()) {
            return;
        }
        const originalFunc = original.elementScrollIntoView;
        modifyPrototypes((prototype) => (prototype.scrollIntoView = function scrollIntoView() {
            const scrollIntoViewOptions = arguments[0];
            if (arguments.length === 1 && isObject(scrollIntoViewOptions)) {
                return elementScrollIntoView(this, Object.assign(Object.assign({}, scrollIntoViewOptions), animationOptions));
            }
            return originalFunc.apply(this, arguments);
        }));
    };

    const elementScrollToPolyfill = (animationOptions) => {
        if (isScrollBehaviorSupported()) {
            return;
        }
        const originalFunc = original.elementScroll;
        modifyPrototypes((prototype) => (prototype.scrollTo = function scrollTo() {
            if (arguments.length === 1) {
                const scrollToOptions = arguments[0];
                if (!isObject(scrollToOptions)) {
                    throw new TypeError("Failed to execute 'scrollTo' on 'Element': parameter 1 ('options') is not an object.");
                }
                const left = Number(scrollToOptions.left);
                const top = Number(scrollToOptions.top);
                return elementScroll(this, Object.assign(Object.assign(Object.assign({}, scrollToOptions), { left, top }), animationOptions));
            }
            return originalFunc.apply(this, arguments);
        }));
    };

    const windowScroll = (options) => {
        var _a, _b;
        const originalBoundFunc = original.windowScroll.bind(window);
        if (options.left === undefined && options.top === undefined) {
            return;
        }
        const startX = window.scrollX || window.pageXOffset;
        const startY = window.scrollY || window.pageYOffset;
        const targetX = nonFinite((_a = options.left) !== null && _a !== void 0 ? _a : startX);
        const targetY = nonFinite((_b = options.top) !== null && _b !== void 0 ? _b : startY);
        if (options.behavior !== "smooth") {
            return originalBoundFunc(targetX, targetY);
        }
        const removeEventListener = () => {
            window.removeEventListener("wheel", cancelScroll);
            window.removeEventListener("touchmove", cancelScroll);
        };
        const context = {
            timeStamp: now(),
            duration: options.duration,
            startX,
            startY,
            targetX,
            targetY,
            rafId: 0,
            method: originalBoundFunc,
            timingFunc: options.timingFunc,
            callback: removeEventListener,
        };
        const cancelScroll = () => {
            cancelAnimationFrame(context.rafId);
            removeEventListener();
        };
        window.addEventListener("wheel", cancelScroll, {
            passive: true,
            once: true,
        });
        window.addEventListener("touchmove", cancelScroll, {
            passive: true,
            once: true,
        });
        step(context);
    };
    const windowScrollPolyfill = (animationOptions) => {
        if (isScrollBehaviorSupported()) {
            return;
        }
        const originalFunc = original.windowScroll;
        window.scroll = function scroll() {
            if (arguments.length === 1) {
                const scrollOptions = arguments[0];
                if (!isObject(scrollOptions)) {
                    throw new TypeError("Failed to execute 'scroll' on 'Window': parameter 1 ('options') is not an object.");
                }
                return windowScroll(Object.assign(Object.assign({}, scrollOptions), animationOptions));
            }
            return originalFunc.apply(this, arguments);
        };
    };

    const windowScrollBy = (options) => {
        const left = nonFinite(options.left || 0) + (window.scrollX || window.pageXOffset);
        const top = nonFinite(options.top || 0) + (window.scrollY || window.pageYOffset);
        if (options.behavior !== "smooth") {
            return original.windowScroll.call(window, left, top);
        }
        return windowScroll(Object.assign(Object.assign({}, options), { left, top }));
    };
    const windowScrollByPolyfill = (animationOptions) => {
        if (isScrollBehaviorSupported()) {
            return;
        }
        window.scrollBy = function scrollBy() {
            if (arguments.length === 1) {
                const scrollByOptions = arguments[0];
                if (!isObject(scrollByOptions)) {
                    throw new TypeError("Failed to execute 'scrollBy' on 'Window': parameter 1 ('options') is not an object.");
                }
                return windowScrollBy(Object.assign(Object.assign({}, scrollByOptions), animationOptions));
            }
            const left = Number(arguments[0]);
            const top = Number(arguments[1]);
            return windowScrollBy({ left, top });
        };
    };

    const windowScrollToPolyfill = (animationOptions) => {
        if (isScrollBehaviorSupported()) {
            return;
        }
        const originalFunc = original.windowScroll;
        window.scrollTo = function scrollTo() {
            if (arguments.length === 1) {
                const scrollToOptions = arguments[0];
                if (!isObject(scrollToOptions)) {
                    throw new TypeError("Failed to execute 'scrollTo' on 'Window': parameter 1 ('options') is not an object.");
                }
                const left = Number(scrollToOptions.left);
                const top = Number(scrollToOptions.top);
                return windowScroll(Object.assign(Object.assign(Object.assign({}, scrollToOptions), { left, top }), animationOptions));
            }
            return originalFunc.apply(this, arguments);
        };
    };

    const polyfill = (options) => {
        if (isScrollBehaviorSupported()) {
            return;
        }
        windowScrollPolyfill(options);
        windowScrollToPolyfill(options);
        windowScrollByPolyfill(options);
        elementScrollPolyfill(options);
        elementScrollToPolyfill(options);
        elementScrollByPolyfill(options);
        elementScrollIntoViewPolyfill(options);
    };

    exports.elementScroll = elementScroll;
    exports.elementScrollBy = elementScrollBy;
    exports.elementScrollByPolyfill = elementScrollByPolyfill;
    exports.elementScrollIntoView = elementScrollIntoView;
    exports.elementScrollIntoViewPolyfill = elementScrollIntoViewPolyfill;
    exports.elementScrollPolyfill = elementScrollPolyfill;
    exports.elementScrollTo = elementScroll;
    exports.elementScrollToPolyfill = elementScrollToPolyfill;
    exports.polyfill = polyfill;
    exports.seamless = polyfill;
    exports.windowScroll = windowScroll;
    exports.windowScrollBy = windowScrollBy;
    exports.windowScrollByPolyfill = windowScrollByPolyfill;
    exports.windowScrollPolyfill = windowScrollPolyfill;
    exports.windowScrollTo = windowScroll;
    exports.windowScrollToPolyfill = windowScrollToPolyfill;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=seamless.js.map
